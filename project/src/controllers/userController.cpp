// Required Libraries
#include <iostream>
#include <string>
#include <termios.h>
#include <unistd.h>
#include <openssl/evp.h>
#include <cstring>
#include <sstream>
#include <iomanip>



// Custom header files
#include "userController.hpp"
#include "taskController.hpp"
#include "subscriptionController.hpp"
#include "courseController.hpp"
#include "userDb.hpp"
#include "user.hpp"
#include "student.hpp"
#include "instructor.hpp"


using namespace std;

UserController *UserController::instance = nullptr; // initialize the static pointer

/*
* Note, generate_hash() was generated by ChatGPT Model 3.5 given the following prompts:
* "how would I implement password Hashing in C++?"
* "can you rewrite the function to return the hashed value to me?"
* "can you rewrite it to take a string"
*/ 

// Function to generate hash value for given password using OpenSSL EVP library
std::string UserController::generate_hash(const std::string& password)
{
    EVP_MD_CTX *mdctx;
    const EVP_MD *md;
    unsigned char hash[EVP_MAX_MD_SIZE];
    unsigned int hash_len;

    // Select hashing algorithm (SHA-256 in this example)
    md = EVP_sha256();

    // Create new message digest context
    mdctx = EVP_MD_CTX_new();

    // Initialize context with hashing algorithm
    EVP_DigestInit_ex(mdctx, md, NULL);

    // Update context with password string
    EVP_DigestUpdate(mdctx, password.c_str(), password.length());

    // Finalize context and generate hash value
    EVP_DigestFinal_ex(mdctx, hash, &hash_len);

    // Clean up context
    EVP_MD_CTX_free(mdctx);

    // Convert hash value to string representation
    std::ostringstream oss;
    oss << std::hex << std::setfill('0');
    for (unsigned int i = 0; i < hash_len; i++) {
        oss << std::setw(2) << static_cast<unsigned int>(hash[i]);
    }
    return oss.str();
}

// returns a pointer to the single instance of UserController, if there is no instance it creates a new one
UserController* UserController::getInstance() {
    if(instance == nullptr) {
        instance = new UserController();
    }
    return instance;
}

// constructor is private to avoid multiple instances of UserController, instead use static method getInstance 
UserController::UserController()
{
    this->currentUser = -1;
    taskController = TaskController::getInstance();
    subscriptionController = SubscriptionController::getInstance();
}

// destructor
UserController::~UserController() { 
	
}

// createStudent
int UserController::createStudent(string name, string email, string password) {
    list<int> tasks = {};
    string hashedPassword = generate_hash(password);
    Student* student = new Student(-1, name, hashedPassword, email, tasks);
    return userDb->createUser(*student);
}

// createInstructor
int UserController::createInstructor(string name, string email, string password) {
    list<int> tasks = {};
    string hashedPassword = generate_hash(password);
    Instructor* instructor = new Instructor(-1, name, hashedPassword, email, tasks);
    return userDb->createUser(*instructor);
}

// deleteUser
void UserController::deleteUser(int userId) {
    // delete personal tasks
    list<int> taskList = this->userDb->getTaskList(getCurrentUser());

    for (int taskId: taskList) {
        taskController->deleteTask(taskId);
    }

    if (userId < 1001) {
        // delete user subscriptions if student
        vector<Course> subscriptions = this->subscriptionController->viewCurrentSubscriptions(userId);

        for (Course course: subscriptions) {
            subscriptionController->removeSubscription(course.getCourseId(), userId);
        }
    // TODO: decide if deleting an instructor should really delete all their courses
    } else {
        // delete user's courses if instructor
        vector<Course> courseList = courseController->getInstructorCourses(userId);

        for (Course course: courseList) {
            this->courseController->deleteCourse(course.getCourseId(), userId);
        }
    }
    // delete the user    
    userDb->deleteUser(userId);

}

void UserController::updateUser(string name, string email) {

    User user = getUserInfo(getCurrentUser(), "");
    user.setName(name);
    user.setEmail(email);
    userDb->updateUser(user, user.getUserId());
}

// getUserInfo
User UserController::getUserInfo(int userId, string email) {
    if (userId == -1) {
        return userDb->getUserInfoByEmail(email);
    } else {
        return userDb->getUserInfoById(userId);
    }

}

//validate credentials entered by the users
bool UserController::validateCredentials(string email, string password) {
    User user = this->getUserInfo(-1, email);

    // Note, this or statement is required because the dummy data is not hashed.
    // Any new user created in DeadlineCentral Will have a hashed password

    if ((user.getPassword() == password) || (user.getPassword() == generate_hash(password))) {
        this->currentUser = user.getUserId();
        return true;
    } else {
        return false;
    }
}


int UserController::getCurrentUser() {
    return this->currentUser;
}

//todo, remove this
void UserController::setCurrentUser(int userId) {
    this->currentUser = userId;
}